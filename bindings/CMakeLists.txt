# SWIG bindings

# Dotnet bindings
option(BINDINGS_DOTNET "Generate bindings for C#" OFF)
option(BINDINGS_PYTHON "Generate bindings for Python" OFF)
option(BINDINGS_UNITY "Generate package for Unity" OFF)
option(BINDINGS_UNREAL "Generate plugin for Unreal" OFF)
option(BINDINGS_RUBY "Generate bindings for ruby" OFF)
option(BINDINGS_JAVA "Generate bindings for java" OFF)
option(BINDINGS_JRUBY "Generate bindings for JRuby" OFF)

if(BINDINGS_DOTNET OR BINDINGS_UNITY)
    set(BINDINGS_DOTNET_CSPROJ CACHE BOOL ON)
    set(BINDINGS_DOTNET_BUILD_PACKAGE CACHE BOOL ON)
    set(BINDINGS_DOTNET_FRAMEWORK_VERSION netstandard2.0 CACHE STRING "dotnet Framework version")
    set(DOTNET_FRAMEWORK_VERSIONS
        v3.5 
        v4 
        v4.5 
        v4.5.1 
        v4.5.2 
        v4.6 
        v4.6.1 
        v4.7.1 
        v4.7.2
        netstandard1.0 
        netstandard2.0
        netstandard2.1
    )
    set_property(CACHE BINDINGS_DOTNET_FRAMEWORK_VERSION PROPERTY STRINGS ${DOTNET_FRAMEWORK_VERSIONS})
    set(BINDINGS_DOTNET ON)
    set(DOTNET_GENERATED_BINDINGS)
    set(DOTNET_TARGET ${PROJECT_NAME}Dotnet)
    set(DOTNET_STAMP ${CMAKE_CURRENT_BINARY_DIR}/bindings/dotnet/dotnet.stamp)
    set(DOTNET_DLL_PREFIX "")
    set(DOTNET_OUTPUT_FOLDER ${CMAKE_BINARY_DIR}/packages/cross-platform/dotnet)
    set(DOTNET_OUTPUT_PACKAGENAME ${DOTNET_TARGET}.${PROJECT_VERSION}.nupkg)
    set(DOTNET_OUTPUT_PACKAGE ${DOTNET_OUTPUT_FOLDER}/${DOTNET_OUTPUT_PACKAGENAME})
    set(DOTNET_OUTPUT_DLL ${DOTNET_OUTPUT_FOLDER}/${BINDINGS_DOTNET_FRAMEWORK_VERSION}/${DOTNET_TARGET}.dll)

    if(WIN32 AND NOT BINDINGS_DOTNET_CSPROJ)
        message(STATUS "Using C# project generated by CMake")
        enable_language(CSharp)
        add_library(${DOTNET_TARGET} SHARED "")
    else()
        message(STATUS "Using C# project generated from .csproj template")
        add_custom_target(${DOTNET_TARGET} ALL DEPENDS ${DOTNET_OUTPUT_PACKAGE})
    endif()
    include(bindings/dotnet/CMakeLists.txt)
endif()

if(BINDINGS_JRUBY)
    find_package(JRuby REQUIRED)

    # JRuby bindings require 
    if(NOT BINDINGS_JAVA)
        message(FATAL_ERROR "JRuby bindings require BINDINGS_JAVA to be enabled")
    endif()
endif()

if(BINDINGS_JAVA)
    set(JAVA_TARGET ${PROJECT_NAME}Java)
    find_package(Java REQUIRED)
    find_package(JNI REQUIRED)
    include(UseJava)
    include(bindings/java/CMakeLists.txt)
endif()

if(BINDINGS_UNITY)
    set(UNITY_TARGET ${PROJECT_NAME}Unity)
    set(BINDINGS_UNITY_EXPORT_PACKAGE CACHE BOOL ON)
    include(bindings/unity/CMakeLists.txt)
endif()

if(BINDINGS_UNREAL)
    set(UNREAL_TARGET ${PROJECT_NAME}Unreal)
    include(bindings/unreal/CMakeLists.txt)
endif()


if(BINDINGS_PYTHON)
    set(PYTHON_TARGET ${PROJECT_NAME}Python)
    option(BINDINGS_PYTHON_LINK_AT_RUNTIME "Link against Python at runtime" OFF)
    set(BINDINGS_PYTHON_VERSION_MAJOR 3 CACHE STRING "Python major version")
    set(BINDINGS_PYTHON_VERSION_MINOR 7 CACHE STRING "Python minor version")
    set(BINDINGS_PYTHON_VERSION_PATCH 0 CACHE STRING "Python patch version")
    set(BINDINGS_PYTHON_VERSION ${BINDINGS_PYTHON_VERSION_MAJOR}.${BINDINGS_PYTHON_VERSION_MINOR}.${BINDINGS_PYTHON_VERSION_PATCH})
    set(Python_FIND_ABI "OFF" "ANY" "ANY") # FORCE cmake to link against RELEASE LIBRARIES

    find_package(Python${BINDINGS_PYTHON_VERSION_MAJOR} ${BINDINGS_PYTHON_VERSION} COMPONENTS Interpreter Development REQUIRED)
    message(STATUS "Found Python ${Python${BINDINGS_PYTHON_VERSION_MAJOR}_FOUND}")
    message(STATUS "Python include dir ${Python${BINDINGS_PYTHON_VERSION_MAJOR}_INCLUDE_DIRS}")
    set(Python_EXECUTABLE ${Python${BINDINGS_PYTHON_VERSION_MAJOR}_EXECUTABLE})
    set(PYTHON_LIB_TARGET Python${BINDINGS_PYTHON_VERSION_MAJOR}::Python)
    set(PYTHON_INCLUDE_DIR ${Python${BINDINGS_PYTHON_VERSION_MAJOR}_INCLUDE_DIRS})
    set(PIP_COMMAND ${Python${BINDINGS_PYTHON_VERSION_MAJOR}_INCLUDE_DIRS}/../Scripts/pip)
    message(STATUS "Pip command: ${PIP_COMMAND}")
    if(WIN32)
        set(PIP_COMMAND ${PIP_COMMAND}.exe)
    endif()
    execute_process(COMMAND ${Python_EXECUTABLE} -c "import wheel" RESULT_VARIABLE WHEEL_NOT-FOUND ERROR_QUIET)
    if(WHEEL_NOT-FOUND)
        message(STATUS "Installing pip wheel package ${PIP_COMMAND}")
        execute_process(COMMAND ${PIP_COMMAND} install wheel)
    endif()

    set(WHEEL_TAG_SCRIPT "import pip._internal; print('-'.join(pip._internal.pep425tags.get_supported()[0]))")
    execute_process(COMMAND ${Python_EXECUTABLE} -c "${WHEEL_TAG_SCRIPT}" 
                    OUTPUT_VARIABLE WHEEL_PLATFORM_TAG 
                    ERROR_QUIET
                    OUTPUT_STRIP_TRAILING_WHITESPACE
    )
    message(STATUS "Wheel tag: ${WHEEL_PLATFORM_TAG}")
    set(PYTHON_WHEEL "${CMAKE_SWIG_ROOT_OUTDIR}/python/dist/${PROJECT_NAME}Python-${CMAKE_PROJECT_VERSION}-${WHEEL_PLATFORM_TAG}.whl")
    add_custom_target(${PYTHON_TARGET} ALL DEPENDS ${PYTHON_WHEEL})
    include(bindings/python/CMakeLists.txt)
endif()

if(BINDINGS_RUBY)
    set(RUBY_TARGET ${PROJECT_NAME}Ruby)
    set(RUBY_VERSION 2.5 CACHE STRING "Ruby version to search for")
    find_package(Ruby ${RUBY_VERSION} REQUIRED)
    include(bindings/ruby/CMakeLists.txt)
endif()